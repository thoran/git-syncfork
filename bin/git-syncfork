#!/usr/bin/env ruby
# git-syncfork

# 20201022
# 0.2.1

# Notes:
# 1. Assumes that the remote is or will be called 'upstream'.
# 2. Assumes that the upstream is hosted on Github.
# 3. Pinched some of maybe_create_upstream_remote() from a very similar program I wrote earlier this year called git-spoon.

# Usage:
# 1. If the upstream remote called upstream doesn't exist, then run git-syncfork with the following arguments:
#  `git syncfork owner/repo`
#   It will create the upstream remote and sync with upstream.
# 2. If the upstream remote called upstream does exist, then run git-syncfork without arguments:
#  `git syncfork`
#   It will sync with upstream.

# Changes since 0.1:
# 1. Checks for the owner and repo being present in ARGV.
# 0/1 (Better handling of missing args.)
# 2. ~ upstream_owner(), upstream_repo to return nil if ARGV[0] isn't parseable.
# 3. - check_args(), since we can rely on the check in maybe_create_upstream_remote() now.
# 4. + maybe_create_upstream_remote(), moved from main() and modified to use Git::Remote.add instead of shelling out directly.
# 5. ~ main(), moved upstream remote check to maybe_create_upstream_remote().

gem 'git.rb'

require 'Git/Branch'
require 'Git/Remote'
require 'Kernel/run'

def upstream_owner
  ARGV[0]&.split('/')&.first
end

def upstream_repo
  ARGV[0]&.split('/')&.last
end

def maybe_create_upstream_remote
  unless Git::Remote.exist?('upstream')
    if upstream_owner && upstream_repo
      url = "git@github.com:#{upstream_owner}/#{upstream_repo}.git"
      Git::Remote.add('upstream', url)
    else
      puts "There is no remote called upstream and one could not be created."
      puts "Run `git syncfork` again with the upstream Github owner and repo like so:"
      puts "", "`git syncfork owner/repo`"
      exit
    end
  end
end

def main
  maybe_create_upstream_remote
  run('git fetch upstream')
  unless Git::Branch.current.master?
    Kernel.run('git checkout master')
  end
  run('git rebase upstream/master')
  run('git push')
  run('git push --tags')
end

main
